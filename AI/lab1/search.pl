% предикат для проверки наличия хоть какого-то факта об X
fact_in_base(X):-
    fact(X, _).

% предикат для доспрашивания пользователя о факте
check(X и не Y):-
    check(X),
    can_ask(Y),
    write("Верно ли что не "),
    ask_notfact(Y), !.

% предикат для доспрашивания пользователя о факте
check(не X и Y):-
    check(Y),
    can_ask(X),
    write("Верно ли что не "),
    ask_notfact(X), !.

% предикат для доспрашивания пользователя о факте
check(X и Y):-
    check(X),
    can_ask(Y),
    write("Может быть "),
    ask_fact(Y), !.

% предикат для доспрашивания пользователя о факте
check(X и Y):-
    check(Y),
    can_ask(X),
    write("Может быть "),
    ask_fact(X), !.   

% -- вспомогательные предикаты для разбора и вычисления выражений --
check(X или Y):-
    check(X),!; check(Y),!.

check(X и Y):-
    check(X), 
    check(Y),!.

check(не X):-
    fact(X, f), !.

check(X):-
    fact(X, t),!.
% ------------------------------------------------------------------

% предикат для получения списка возможных исходов
results(R):-
    bagof(X, result(X), R).

% предикат для проверки нужно ли доспрашивать факт
can_ask(Y):-
    string(Y),
    not(fact_in_base(Y)),
    input(Y).

% вывод и запрос ответа для пользователя
ask(T, X):-
    format("~s?~n", T), read_string(user_input, "\n", "\r", _, X).

% запрос факта для доспрашивания типа a X и Y
ask_fact(X):-
    ask(X, Y), change_base(X, Y). 

% добавление факта t и выход с true
change_base(X, "да"):-
    asserta((fact(X, t):-!)),!.

% добавление факта f и выход с false
change_base(X, _):-
    asserta((fact(X, f):-!)), fail.

% запрос факта для доспрашивания типа a не X и Y
ask_notfact(X):-
    ask(X, Y), change_base_not(X, Y).

% добавление факта f и выход с true
change_base_not(X, "да"):-
    asserta((fact(X, f):-!)),!.

% добавление факта t и выход с false
change_base_not(X, _):-
    asserta((fact(X, t):-!)), fail.

% предикат для получения списка всех возможных правил
rules(R):-
    bagof(X значит Y, X значит Y, R).

% предикат для сбора выведенных возможных исходов
collect_results(R):-
    bagof(X, (result(X), fact(X, t)), R).

% предикат пробует применить правило
try_rule(_ значит Y):-
    fact_in_base(Y), !, fail. % если правило уже было применено, и из него получен результат, то больше не используем его

try_rule(X значит Y):-
    check(X), % если требования правила истинны
    asserta(fact(Y, t)). % добавляем факт в базу знаний

% предикат для применения всех правил, пока находится подходящее к применению правило
try_all_rules([], _):-!. % не нашлось подходящего правила
try_all_rules([H|_], R):-
    try_rule(H), !, % если правило подошло
    try_all_rules(R, R). % начинаем опять с первого правила

try_all_rules([_|T], R):- % если правило не подошло
    try_all_rules(T, R). % идем к следующему

% прямой логический вывод
direct_search:-
    rules(R),
    try_all_rules(R, R).

% предикат для распечатки списка
print_list([], _):-!.
print_list([H|T], N):-
    format("~d. ~s\n", [N, H]),
    N1 is N + 1,
    print_list(T, N1).

% подведение итогов
summarize:- % если нашелся хоть один исход
    collect_results(Res), % сбор выведенных исходов
    write("Выявлены следующие возможные проблемы:\n"),
    print_list(Res, 1), % распечатка возможных неполадок
    write("\n").

summarize:- % если не нашелся
    write("Предоставленных фактов недостаточно для диагностики.\nПопробуйте уточнить данные и повторите диагностику еще раз.\n").