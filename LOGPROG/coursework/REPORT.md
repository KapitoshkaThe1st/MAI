# Отчет по курсовому проекту
## по курсу "Логическое программирование"

### студент: Куликов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |   8.12.2018           |   5            |
| Левинская М.А.|              |               |

## Введение

В ходе работы над данным курсовым проектом будут получены знания и навыки в области логического программирования, в частности на языке Prolog, которые будут применены для решения реалистичной задачи. Также будут приобретены базовые навыки обработки текста и, вероятно, углублены знания и улучшены навыки использования высокоуровневых языков программирования.

## Задание

1. Создать родословное дерево своего рода на несколько поколений (3-4) назад в стандартном формате GEDCOM с использованием сервиса MyHeritage.com

2. Преобразовать файл в формате GEDCOM в набор утверждений на языке Prolog, используя следующее представление: с использованием предикатов father(отец, потомок) и mother(мать, потомок).
3. Реализовать предикат проверки/поиска brotherinlaw(деверь, жена).

4. Реализовать программу на языке Prolog, которая позволит определять степень родства двух произвольных индивидуумов в дереве
5. [На оценки хорошо и отлично] Реализовать естественно-языковый интерфейс к системе, позволяющий задавать вопросы относительно степеней родства, и получать осмысленные ответы.

## Получение родословного дерева

С помощью сервиса  MyHeritage.com было построено генеалогическое дерево до 4-го колена.
Далее оно было экспортировано в формате GEDCOM.

## Конвертация родословного дерева

Для обработки и конвертации полученного .ged файла дерева родословной был выбран язык программирования Python, который позволяет довольно легко проводить обработку текста.

Прежде всего необходимо учесть, что стандартное использования предикатов, заданных вариантов не может сохранить данные о гендере индивида в частных случаях. А именно, если у индивида нет детей, то нет места и самому утверждения о том, что он является отцом или матерью другого. Других способов явного задания пола инивида согласно заданному варианту нет. Таким образом существует 2 варианта: ввести дополнительный формат фактов male\female(Ind), где Ind -- имя индивида; или же добавить опцию к существующему формату. Например, если у индивида нет детей, явно прописать father\mother(Ind, nobody).

В данном случае позволю себе вольность и выберу второй вариант т.к. он не противоречит условию задания, и решает возникшую проблему.

Алгоритм обработки таков:
Построчно считывая данные входного файла формируем словарь, хранящий необходимые данные об каждом индивиде (имя, пол, принадлежность какой-либо семье) и идентификатор индивида в качестве ключа. А также словарь семей, хранящий идентификаторы идентификаторы мужа, жены и список идентификаторов их потомков.

Далее согласно формату и вышесказанному допущению формируем факты `imother\ifather(отец\мать, потомок\nobody)`. Далее на основе полученных фактов путем введения дополнительного правила  программа на Prolog'е сможет определить действительную отцовскую\материнскую связь.

## Предикат поиска родственника

Реализован предикат поиcка деверя (брата мужа жены):

`brotherinlaw(Д, Ж) :- brother(Д, М), husband(М, Ж).`, где Д - деверь, Ж - жена, М - муж.

Т.о. предикат находит индивидов, удовлетворяющих условию, что у деверя есть брат, который женат,на некоторой женщине.

Для реализации данного предиката использованы другие предикаты `brother(брат1, брат2)` - предикат, определяющий являются ли два индивида братьями и предикат `marrieds(супруг1, супруг2)` - предикат, определяющий являются ли два индивида супругами.

Примеры работы на полученных ранее фактах языка предикат:

```prolog
?- brotherinlaw(X, Y).
X = 'Николай Смирнов',
Y = 'Наталья Смирнова' ;
X = 'Алексей Федорович Куликов',
Y = 'Римма Крупина' ;
X = 'Алексей Федорович Куликов',
Y = 'Римма Крупина' ;
false.
```

```prolog
?- brotherinlaw('Николай Смирнов', Y).
Y = 'Наталья Смирнова' ;
false.
```

```prolog
?- brotherinlaw(X, 'Римма Крупина').
X = 'Алексей Федорович Куликов' ;
false.
```

## Определение степени родства

Для определения степени родства был использован поиск с итеративным заглублением и записью родственной цепочки.

```prolog
limited_path([Cur|T], Cur, 1, [Cur|T], []).
limited_path([Cur|T], Goal, N, Result, [Rel|TT]):-
    N > 0,
    move(Cur, Next, Rel),
    not(member(Next, [Cur|T])),
    N1 is N - 1,
    limited_path([Next, Cur|T], Goal, N1, Result, TT).

num_generator(1).
num_generator(X):-
    num_generator(XX),
    X is XX + 1.

depth_limit(40).

iterative_deeping_search(Start, Finish, Path, Rel):-
    num_generator(N),
    depth_limit(Lim),
    (N > Lim, !, fail;
    limited_path([Start], Finish, N, Path, Rel)).
```

Здесь используется станндартный алгоритм поиска с итеративным заглублением, который был реализован во время работы над 3-й лаборатороной работой, и в дальнейшем адаптирован для решения поиска родственнной связи.


```prolog
move(X, Y, father):-father(X, Y).
move(X, Y, mother):-mother(X, Y).
move(X, Y, brother):-brother(X, Y).
move(X, Y, sister):-sister(X, Y).
move(X, Y, son):-son(X, Y).
move(X, Y, daughter):-daughter(X, Y).
```

Так же были дополнительно описаны несколько предикатов `move` устанавливающих правила перехода между состояниями. В качестве третьего аргумента указан атом, обозначающий степень родства для перехода из предыдущего состояния в текущее.

```prolog
relative(X, Y, R):-
    iterative_deeping_search(X, Y, _, R), !.
```

Для удобства использования и дополниетльной смысловой нагрузки предикат поиска обернут в предикат `relative`.

Примеры использования:

```prolog
?- relative('Алексей Куликов', 'Алексей Смирнов', P).
P = [son, son, sister, mother].

?- relative('Елена Исаева', 'Федор Куликов', P).
P = [mother, son, son, son].
```

Первый пример означает, что некто Алексей Куликов является сыном сына сестры матери Алексея Смирнова. И действительно Алексей Смирнов является сыном сестры моей бабушки. Следовательно поиск родственных связей работает корректно.

## Естественно-языковый интерфейс

Для реализации естественно-языкового интерафейса были использованы встроенные средства диалекта SWI-Prolog для разбора DCG грамматик.

```prolog
qst(Keyword, [Actor], wi) --> [who, is], [Actor], [Keyword], [?].
qst(Keyword, [Actor], wa) --> [who, are], [Actor], [Keyword], [?].
```

При помощи данных правил из вводимого пользователем вопроса выцепляются интересующие нас данные. А именно Keyword - слово, определяющее степень родства (например brother, son и т.д.),
Переменная Actor обозначает индивида, для которого мы ищем человека, приходящегося ему кем-то, что обозначит переменная Keyword. Так же мы по структуре предложения определяем тип вопроса, и так же извлекаем его из предложения.

Далее найденные данные передаются в предикат `find_answer()`, который в зависимости от типа вопроса ищет ответ на него для переданных аргументов.

Вот одно из определений предиката `find_answer()`:

```prolog
find_answer(X, Y, wi, A):-
    append([X, A], Y, R),
    P=..R,
    call(P).
```

Внутри него из переданных аргументов X и Y и не связвнной переменной A формируется список. На первой позиции списка стоит переданное название функтора X, далее идет искомый индивид A, после чего к списку в конец добавляется Y. Y -это список известных нам индивидов, для которых и осуществляется поиск.

Далее при помощи оператора `=..` формируем структуру X(A, Y), которую потом принудительно вызываем на исполнение как предикат. Далее в базе знаний ищется подходящий индивид. Это и есть ответ на пользовательский вопрос. Другие предикаты, отвечающие на различиные типы вопросов реализованы приблизительно таким же способом, различается только суть вопроса.

Так же частично учитывается контекст. Т.е. пользователь может вместо указания полных имен индивидов
указывать местоимения их обозначающие.

Например, если предыдущим шагом был вопрос:

`who is 'Иван Куликов' son ?`

То следующий запрос может быть задан в форме:

`who are his children ?`

При этом ответом на вопрос будет список детей Ивана Куликова.

Эта функция программы работает благодаря подмене местоимений на полные имена и дальнейшем поиске по полному имени. Контекст сохраняется в динамическом факте, который раз от раза меняется, если вопрос задается про нового человека с указанием полного его имени.

Подмена осуществляется с помощью предиката `change()`.

```prolog
change([], []).
change([X|T], [L|TT]):-
    change(T, TT),
    member(X, [she, he, his, her]), last(L),!.
change([X|T], [U|TT]):-
    change(T, TT),
    member(X, [i, my, me]), user(U), !.
change([X|T], [X|TT]):-
    change(T, TT).
```

В зависимости от местоимения оно подменяется реальным именем, хранящимся как факт `last()`.

Существует ограничение на типы вопросов и виды родственных связей.

Возможные вопросы:

- who is/are act rel ?
- how many rel do/does act have ?
- whose rel is/am act ?
- is/am act1 act2 rel ?
- who is/am act1 to act2 ?

Возможные степени родства:

- child
- son
- daughter
- father
- mother
- parent
- grandmother
- grandfather
- grandson
- granddaughter
- sibling
- brother
- sister
- marrieds
- husband
- wife
- brotherinlaw

## Выводы

Встроенные средства работы с DCG-грамматиками оказались довольно удобны и сэкономили мне кучу времени. Было бы гораздо болезненее писать разбор предложений без их помощи.

Кроме того, т.к. они основаны на разностных списках, а не на операции разделения списка при помощи `append`, что играет на руку, когда встает вопрос о производительности.

Как выяснилось при помощи Пролога можно довольно удобно парсить текст. Жаль, что слишком поздно это понял. Возможно на досуге познакомлюсь с этим поближе.

Так же на последних этапах работы над курсовым проектом пригодился опыт реализации поиска в пространстве состояний на языке Пролог. Для определения степени родства каким-то совершенно интуитивным способом решения оказался поиск в пространстве состояний. Реализованный ранее алгоритм был с легкостью адаптирован под данную задачу.

Это наталкивает на мысль, что возможно гораздо больший класс задач может быть решен подобным методом.

Данный проект оказался довольно интересен благодаря его разносторонности. В процессе работы над ним пришлось познакомиться с парсингом текстовых файлов, хранящих данные в формате GEDCOM.
Для этого познакомился с языком Python. Оказалось, что он довольно удобен в решении задач, для которых нам его порекомендовали. В дальнейшем, как уже было сказано, пригодились уже приобретенные навыки решения задач поиска в пространстве состояний.

Так же, как часть курсовой работы, был написан реферат, в ходе работы над которым пришлось ознакомиться с некоторой специализированной литературой по логическому программированию. Что, несомненно, не останется без следа. Знания - сила!

В результате создана интерактивная программа, позволяющая задавать вопросы на естественном языке (конечно, с некоторыми ограничениями) и получать ответы на них.
