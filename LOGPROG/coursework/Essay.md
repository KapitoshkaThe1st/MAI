# Реферат
## по курсу "Логическое программирование"

### студент: Куликов А.В.

## Математическая логика и логическое программирование: сравнение

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

### Введение

Для сравнения логического программирования и математической логики надо для начала обозначить то, что мы под этими терминами понимаем.

Математическая логика - это раздел математики, изучающий математические обозначения, формальные системы, доказуемость математических суждений, природу математического доказательства в целом, вычислимость и прочие аспекты оснований математики.

Логическое программирование - парадигма программирования, в основе которой лежит автоматическое доказательство теорем. Также логичекое программирование является одним из разделов дискретной математики, который изучает принципы логического вывода информации на основе заданных фактов и правил вывода.

Так как логичеческое программирование - это все-таки программирование, а программирования не может быть без языка программирования. Поэтому сравним с каким-нибудь конкретным языком логического программирования. Самым известным и используемым из них является Пролог. С ним и будем сравнивать.

### Схожесть сфер интересов двух наук

Из определений ясно, что сферы интересов этих двух наук как минимум пересекаются. Обе дисциплины изучают способы доказательства истинности либо ложности некоторых утверждений, теорем. Изучаются правила вывода на основе некоторых аксиом и т.д.

И действительно, далее будет показано, что эти две науки не просто схожи, а практически неотделимы друг от друга. Хотя бы потому что логическое программирование основано на достижениях в области математической логики.

### Схожесть методов представления объектов

Для того, чтобы делать высказывания об объектах для начала неплохо было бы понять как описываются объекты.
В математической логике, а в частности в исчислении предикатов, для описания объектов используются термы. Их существует три вида:

- Константы - это символы, обозначающие некоторые индивидуальные объекты или понятия.

- Переменные так же обозначают индивидуальные объекты или понятия, но в каждый раз разные. Для определения области действия переменных используются кванторы.

- Третий тип – составные термы. Они состоят из функционального символа и упорядоченного множества других термов, выступающий в роли аргументов. Составной терм предназначается для обозначения индивидуального объекта, который зависит от других индивидуальных объектов, представленных его аргументами. Функциональный символ описывает характер зависимости.

В прологе существуют эквивалентные способы для описания объектов.
Константа соответствуют как атомы языка Пролог.

Переменным в математической логике, как ни странно, соответствуют переменные языка Пролог.

Эквивалентом для составных термов являются структуры языка Пролог. Каждому составному терму в исчислении предикатов можно поставить в соответствие структуру с функциональным символом на месте функтора и теми же аргументами.

Более того, для того, чтобы делать высказывания об объектах необходим еще способ описания отношений между ними. В математической логики в качестве него выступает предикат.

Предикат - это, как известно, логическая функция, которая может принимать два значения: «истина» и «ложь». Предикаты являются атомарными формулами или атомами логики предикатов первого порядка.

Атомарное высказывание (или предикат) состоит из предикатного символа и некоего множества термов-аргументов.

Далее в исчислении предикатов из них при помощи логических операций уже могут быть построены высказывания.

В Прологе предикаты соответствуют целевым утверждениям.

Как было показано, способы, используемые для представления объектов и построения высказываний о них в исчислении предикатов, соответствуют способам, имеющимся для этого в языке Пролог.

Таким образом, можно сделать промежуточный вывод: математическая логика и логическое программирование оперирует, грубо говоря, одними и теми же понятиями. Этот немаловажный факт идет в «копилку» сходств логического программирования и математической логики.

Небольшим отличием логического программирования, а именно языка Пролог, является лишь тот факт, что структура языка Пролог может быть использована как в качестве целевого утверждения, так и в качестве аргумента для другой структуры. В исчислении предикатов все несколько строже. Там четко разделены функциональные символы и предикатные символами. Функциональные символы используются только в качестве функторов для построения аргументов. Предикатные, в совю очередь, могут выступать только в роли функторов для построения высказываний.
Возможно в других языках логического программирования нет такого отличия, и мне не стоило всех стричь под одну гребенку, не имея достаточной квалификации в этой области.

### Форма записи дизъюнктов

Как было сказано выше, из атомарных формул при помощи логических операций строятся высказывания, общезначимость, выполнимость либо противоречивость которых и необходимо доказывать.

Для удобства использования тех методов, на которых основано логическое программирование
существует особая форма записи формул. Для приведения высказывания к такой форме необходимо совершить определенную последовательность действий, которую полностью описывать здесь не имеет смысла. Стоит лишь сказать что она состоит из следующих шагов:

- исключение импликаций и эквивалентностей

- перенос отрицания внутрь формулы
- сколемизация
- вынесение кванторов общности в начало формулы
- использование дистрибутивных законов для & и V
- выделение множества дизъюнктов

Дизъюнкт - это совокупность литер, одни из которых не содержат, а другие содержат знак отрицания.

Таким образом после произведения указанных действий над высказыванием мы получаем эквивалентное начальной формуле множество дизъюнктов. Для них принята удобная форма записи.

Слева записываются литералы без отрицания, затем знак ':-', после этого идут все литералы имеющие отрицание.  Естественно порядок записи литералов не важен (в математической логике, для Пролога существуют некоторые нюансы).

Например,

`A; B :- C, D, E.`

Данная запись эквивалентна следующей:

`A V B V ~C V ~D V ~E`

Далее по закону Де Моргана:

`A V B V ~(C & D & E)`

Что по определению является следующим:

`C & D & E => A V B`

Отсюда виден смысл знаков  ';', ',' и ':-'. Знаку ';' соответствует логическое ИЛИ, знаку ',' соответствует логическое И, а знак ':-' означает «следует из».

Очевидно сходство такой записи высказывания с записью правил на языке Пролог.

Исключением является лишь то, что слева от знака ':-' присутствует не один литерал, как это есть в Прологе. Этому есть своя причина, о которой будет сказано чуть ниже.

### Доказательство в математической логике и логическом программировании

Общезначимой формулой в логике предикатов называется такая формула, которая на любой интерпретации является истинной.
Противоречивой формулой называется формула, имеющая на всех своих интерпретациях, значение «ложь».

В логике предикатов для каждой формулы существует огромное множество различных интерпретаций, поэтому ее общезначимость либо противоречивость невозможно доказать с помощью проверки истинности на всем множестве интерпретаций.

Следовательно в логике предикатов нет никакого алгоритма, который позволял бы доказать общезначимость той или иной формулы. Но, к счастью, существуют алгоритмы, позволяющие ее подтвердить.

Один из способов  это сделать основан на возможности для любой формулы найти такую интерпретацию, на которой она ложна, если такая интерпретация в принципе существует.
Если такой интерпретации нет, то формула является общезначимой.

Для того чтобы формула была общезначима необходимо и достаточно, чтобы ее отрицание было противоречиво. Следовательно, доказав противоречивость отрицания формулы, мы докажем ее общезначимость. Эта идея лежит в основе всех алгоритмов автоматического доказательства теорем.

Самым эффективным способом поиска доказательства общезначимости является метод резолюций.
Она по сути своей является поиском опровержений, т. е. в точности как сказано выше вместо прямого доказательства общезначимости доказывается противоречивость отрицания.

### Метод резолюций

Суть метода состоит в том, что если в двух дизъюнктах присутствуют две одинаковые литеры, но в одном из них литера с отрицанием, а в другом – без (это называется контрарными литерами), то следствием этих двух дизъюнктов является новый дизъюнкт, состоящий из дизъюнкции оставшихся литер. Контрарные как бы вычеркиваются, как если бы это происходило на бумаге. Полученный дизъюнкт называется резольвентой прошлых двух.

В форме записи, которая была описана выше применение метода резолюции выглядит примерно так:
В данной форме записи то, что литеры являются контрарными означает, что в разных дизъюнктах они находятся по разные стороны знака ":-".
Следовательно такие литеры вычеркиваются.
Например, для двух дизъюнктов:

`A; B; C :- D, E, F.`
`X; Y :- B, V, W.`

После вычеркивания B и слияния оставшихся получаем новый дизъюнкт:

`A; C; X; Y :- D, E, F, V, W.`

Он является следствием исходных.

Нахождение в двух дизъюнктах контрарных литер выполняется довольно просто, если дизъюнкты не содержат переменных. Дизъюнкты, содержащие переменные, необходимо унифицировать, то есть найти такую подстановку, в результате которой исходные дизъюнкты будут содержать контрарные литеры.

Поиск в двух дизъюнктов контрарных литер довольно прост. Необходимо лишь найти литеры, которые в один дизъюнкт входят с отрицанием, а в другой – без.

Интересное начинается, когда в дизъюнкты входят переменные. Тут нельзя просто принять за контрарные две литеры с переменными, т. к. никто не гарантирует, что они примут одно и то же значение. Тут в игру и вступает процесс унификации.

Унифицировать две атомарные формулы значит найти такую подстановку конкретных термов на место переменных, чтобы после замены переменных в исходных дизъюнктах на значения из подстановки дизъюнкты содержали контрарные литеры. При унификации формул происходит конкретизация значений переменных (конкретизация переменных), в результате которой формулы становятся идентичными.

В логическом программировании, представителем которого является язык Пролог так же существует процесс унификации. Выражаясь терминами Пролога, можно описать процесс унификации так: если имелось два дизъюнкта, представленных структурами, и было выполнено сопоставление соответствующих подструктур, то результат соединения этих структур и был бы представлением нового дизъюнкта.
После унификации все происходит согласно методу резолюций.

Используя метод резолюций, можно автоматически доказывать теоремы, выводя их из аксиом. Необходимо лишь задать исходные высказывания, а следствие из них будет получено автоматически с помощью правил вывода.

Метод резолюций можно применять к любому множеству дизъюнктов с целью проверки их невыполнимости (противоречивости). Рассмотрим сначала метод резолюций для логики высказываний.

Если дизъюнкт не содержит литер, то его называют пустым и и считают тождественно ложным.
Резольвента двух единичных дизъюнктов (если она существует) – пустой дизъюнкты.

Как нам поможет метод резолюции в доказательстве утверждений?

Если найдено множество дизъюнктов, которые представляют некоторую формулу. Тогда эта формула противоречива тогда и только тогда, когда противоречиво множество дизъюнктов. Если множество дизъюнктов содержит пустой дизъюнкт, то невыполнимо. В ином случае проверяется, может ли из него быть получен пустой  дизъюнкт.

Вывод из множества множества дизъюнктов, соответствующего какой-либо формуле пустого дизъюнкта называется опровержением этой формулы, а следовательно доказательством ее отрицания.

Из всего вышесказанного следует, что если множество исходных гипотез непротиворечиво, то надо добавить к нему дизъюнкты, отрицающие высказывание, которое следует доказать. Если доказываемое высказывание следует из заданных гипотез, то получим пустой дизъюнкт. Добавляемые к множеству гипотез дизъюнкты называются целевыми.

Это все  конечно хорошо, существует рабочий способ для автоматического доказательства теорем.

Для того, чтобы из исходных вывести пустой дизъюнкт, необходимо совершить некоторое количество конкретных шагов. На каждом из шагов правило резолюции будет применяться к каким-то из из существующих аксиом, либо к выведенным ранее дизъюнктам. Зачастую количество таких промежуточных, а может быть и вовсе побочных дизъюнктов, не имеющих никакого отношения к доказательству, оказывается довольно велико, и в них запросто можно «заплутать». И, в таком случае, на решение задачи либо уйдет слишком много времени, либо решения не будет найдено совсем. Это, несомненно является проблемой.  

Но у данной проблемы существует решение. Эту проблему решает дизъюнкт Хорна.

### Дизъюнкт Хорна

Хорновский дизъюнкт - это дизъюнкт, содержащий не более одной литеры без отрицания.

Т.е. если рассматривать в удобной форме записи, выглядят они примерно вот так:

`A:-B,C,D.`

Совсем идентично правилу записи правил на языке Пролог.

Т.к. по определению дизъюнкт Хорна – это такой дизъюнкт, который содержит не более одной положительной литеры, то сууществует всего два вида хорновских дизъюнктов.
Хорновским дизъюнктом с заголовком называют дизъюнкт, содержащий одну литеру без отрицания. Он может содержать одну или несколько литер с отрицанием или не содержать их вообще, например:

`A:-B,C,D.`

или

`A:-`

Последний можно записать просто как

`A.`

Хорновский дизъюнкт без заголовка - это дизъюнкт, который совсем не содержит литер без отрицания.

Напримерж

`:-A, B, C.`

Если применить метод резолюции к двум дизъюнктам Хорна, имеющим заголовки, то в результате
получим опять хорновский дизъюнкт с заголовком. А нам  для доказательства невыполнимости нам нужно получить пустой дизъюнкт,  не имеющий заголовка. Отсюда следует, что для опровержения всегда необходим хотя бы один дизъюнкт, не имеющий заголовка.

Если же среди исходных их имеется несколько, то доказательство каждого нового дизъюнкта методом резолюций может быть преобразовано в доказательство, в котором используется не более чем один дизъюнкт без заголовка.

Таким образом любой задаче, которая может быть выражена с помощью хорновских дизъюнктов,  требуется в точности один дизъюнкт без заголовка т. е. целевой.
Остальные дизъюнкты должны иметь заголовки. Т. е. должны являться гипотезами.
По вышесуказанным причинам именно хорновские дизъюнкты были взяты за основу основы для создания программных систем автоматического доказательства теорем.
Метод резолюций для хорновских дизъюнктов куда более прост. Поэтому в логическом программировании, по крайней мере на языке Пролог, используется ограниченный вариант метода резолюций, рассчитанный на работу с одной литерой в левой части. Это, пожалуй, и является главным отличием логического программирования от математической логики.
Как это пересекается с Прологом.

Как было показано, некоторые формулы, преобразованные к специальному виду сразу выглядят в точности так же, как и утверждения в Прологе. Такие формулы представлены в форме хорновских дизъюнктов. Остальные формулы имеют несколько литералов с левой стороны от знака ':-' тем самым отличаясь, от утверждений на языке пролог. Этому есть объяснение.
В общем случае, в исчислении предикатов дизъюнкты могут иметь произвольное количество атомарных формул без отрицания (т. е. справа от знака ':-' ). Пролог, как уже было сказано, непосредственно можно представить только хорновские дизъюнкты.

Хорновским дизъюнктам, имеющим заголовок в Прологе эквивалентны утверждения.
Хорновским дизъюнктам без заголовка соответствуют внутренние и внешние цели языка Пролог. Внутренняя цель, что символично, описывается в Прологе в точности так же, как целевой дизъюнкт в логике предикатов.
:- A, B, C.

Требование о наличии одного и только одного дизъюнкта без заголовка, накладываемое на представление задачи в виде хорновских дизъюнктов, с находит отражение в процессе вывода в программе на языке Пролог.
В каждый момент времени имеется только одно активное целевое утверждение. Все остальные утверждения имеют заголовки и соответствуют гипотезам в математической логике.  

Так же известно, что доказательство теорем в Прологе основано на методе резолюций для хорновских дизъюнктов. При этом математической логикой конкретно не указан способ выбора следующих дизъюнктов для применения метода. В Прологе же в качестве стратегии выбора взята одна из разновидностей линейной входной резолюции.
Процедура доказательства примерно такова:

Берется целевой дизъюнкт и одна из гипотез, к ним применяется правило резолюции. Как результат получаем новый дизъюнкт. Для нового дизъюнкта выбираем гипотезу и опять применяем правило резолюции. И так до тех пор, пока не будет выведен пустой дизъюнкт, что говорит об успешности доказательства, либо, если процедура не привела к решению, то ищутся альтернативные пути.  Т.е. идеальная ситуация такова: в начальный момент имеем внутреннюю или внешнюю цель, а в конце процесса, получаем пустое утверждение.

На каждом этапе ищется утверждение, заголовок которого сопоставим с одним из целевых утверждений (процесс унификации). При этом, если требуется, конкретизируются свободные переменные. Далее, образно выражаясь, удаляется целевое утверждение, с которым произошло сопоставление, а затем к целевым утверждениям, которые системе еще предстоит согласовать, добавляется тело найденного утверждения, в котором произведена конкретизация переменных. Причем тело данного утверждения записывается вперед имеющихся.  То есть следующим будет сопоставляться первый литерал только что рассмотренного утверждения. Хотя,  вообще говоря, математическая логика не накладывает четкие требования на этот счет. С таким же успехом мог быть выбран и второй, и третий и т. д. Просто Пролог реализован именно таким образом. Поэтому данная стратегия является чуть более ограниченной, чем сама по себе линейная входная резолюция.
За счет того, что новые целевые утверждения добавляются именно перед уже имеющимися реализуется стратеги поиска в глубину. Это значит, что Пролог сперва завершит доказательство согласованности всех подцелей, а только потом, если они завершились успешно, перейдет к обработке следующих целей.

Существуют альтернативы стратегии поиска в глубину. Например стратегия поиска в глубину имеет ряд преимуществ, хотя и без недостатков не обошлось. Поиск в ширину сохраняет все альтернативные пути решения задачи, и  на каждом шаге, лишь чуть-чуть продлив один путь переходит к другому.  Такая стратегия поиска вширь имеет серьезное преимущество – если решение существует, то оно обязательно будет найдено, что не гарантируется поиском в глубину. С другой поиск в глубину гораздо проще и требует меньших затрат памяти при реализации на вычислительных машинах с традиционной архитектурой.

### Некоторые отличия теории от практики

Так же нельзя не упомянуть про некоторые конфликты реального программирования на Прологе и математической логики.

Математическая логика, в моем понимании, подразумевает полную декларативность определений, утверждений, доказательств и т. п.

Что, в теории, возможно никак не вступает в конфликт с логическим программированием.
На практике же в языке Пролог есть некоторые допущения, которые нарушают делкаративность языка и привносят некую императивную составляющую.

Источником императивности в прологе являются предикаты, обладающие побочными эффектами (ввод, вывод и тому подобное). Использование `write(X)`, к примеру, как бы берет с программиста обещание, что программа в процессе вывода точно доберется до данного предиката.

Математические вычислениия в Прологе основаны на операторе `is`, который требует того, чтобы всем переменные, участвующим в вычислении были некоторые значения. Это так же нарушает, например, принцип из математичиской логики, говорящий, что порядок литералов в дизъюнкте не имеет значения.

Так же императивность вносят и предикаты, управляющие процессом вывода такие как отсечение `!`, предикаты `true`, `fail`, `repeat` и тому подобные. Они не несут в себе, по сути, никакой информации, о доказываемом высказывании, а влияют на процесс доказательства.
Например, какие альтернативы уже можно отбросить при достижении какого-то этапа доказательства.

Сильнее всего вступают в конфликт с математической логикой предикаты управления базой знаний Пролога такие как `assert`, `retract`, добавляющие или удаляющие аксиомы прямо «на лету». Это может приводить к тому, что истинные ранее правила становятся ложными, ложные — истинными. И вообще на разных этапах доказательства окажется разный набор аксиом. Этого логика не допускает.

Безусловно, эти управляющие предикаты созданы не просто так, и их использование более чем оправдано, с точки зрения оптимизации и тому подобных практических вещей. Предикаты ввода/вывода тоже необходимы для организации «общения» системы с пользователем. Так же порой не обойтись без динамического изменения базы знаний Пролога. Но тем не менее, теряется математическая строгость, из-за этого языка становится менее выразительным, хотя, конечно, более практиным.

### Вывод

Итак, резюмируя все вышесказанное, надо сказать, что логическое программирование определенно имеет гораздо больше сходств с математической логикой, чем различий. Если бы это было не так, то, на самом деле это было бы довольно странно. Так как логическое программирование все-таки основано на достижениях математической логики и является одним из ее приложений, призванной в какой-то мере автоматизировать процесс логического доказательства.

Невозможно не заметить, что программы на языках логического программирования довольно похожи на гипотезы о проблемной области, а вопросы очень похожи на теоремы, которые требуется доказать. Программирование на Прологе имеет мало общего с процессом выдачи машине указаний о том, что и когда следует делать. Оно скорее состоит в передаче машине информации, которая предполагается истинной, и обращении к ней с вопросами о возможных следствиях из этой информации. И ожидания от программы результатов, полученных логическим выводом.

### Список использованных источников информации

Литература:

- У. Клоксин, К. Меллиш Программирование на языке Пролог

Интернет-ресурсы:

- aiportal.ru
- wikipedia.com
- mathhelpplanet.com