# Отчет по лабораторной работе №1
## Работа со списками и реляционным представлением данных
## по курсу "Логическое программирование"

### студент: ______

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |               |

## Введение

В Прологе основным способом хранения наборов данных являются списки.

Списки в Прологе - это рекурсивный тип данных. Он представлен как голова (один элемент) и другой список (все оставшиеся элементы).

Именно поэтому все операции над списками реализуют при помощи рекурсии.

Напротив, массив в императивных языках - это набор ячеек памяти выделенный сплошняком.
  
В традиционных языках программирования самыми похожими структурами являются односвязные списки.

## Задание 1.1: Предикат обработки списка

`remove_last3(L, R)` - предикат, "обрезающий" 3 последних элемента в списке L (Вариант 3)

Примеры использования:

```prolog
?- remove_last3([1, 2, 3, 4, 5], X).
X = [1, 2].
```

Реализация (без использования стандартных предикатов):

```prolog
remove_last3([_, _, _], []):-!.
remove_last3([H|T1], [H|T2]):-
    remove_last3(T1, T2).
```

Рекурсивно спускаемся, "отрезая" голову списку, пока не останется 3 элемента. Далее в результирующем списке вместо 3-х последних окажется пустой список. На обратном ходе рекурсии элементы возвращаются в списки. Т.о. в R получаем обрезанный список.

Реализация (с использованием стандартных предикатов):

```prolog
sremove_last3(List, Result):-
    prefix(Result, List),
    length(List, Len),
    Res_len is Len - 3,
    length(Result, Res_len).
```

Находим префикс исходного списка, имеющий длинну на 3 меньшую, чем длина исходного. Т.о. в R получаем обрезанный список.

## Задание 1.2: Предикат обработки числового списка

`average_list(L, A)` - предикат для нахождения среднего арифметического всех элементов списка L.  (Вариант 8)

Примеры использования:

```prolog
?- average_list([1, 2, 3, 4, 5], X).
X = 3
?- average_list([8, 800, 5555, 35, 35], X).
X = 1286.6
```

Реализация (без использования стандартных предикатов):

```prolog
length_list([], 0).
length_list([_|T], Len):-
    length_list(T, Tmp), Len is Tmp + 1.

sum_list([], 0). 
sum_list([H|T], S):-
    sum_list(T, SS), S is SS + H.

average_list(List, Avg):- 
    sum_list(List, Sum),
    length_list(List, Cnt),
    Avg is Sum/Cnt.
```

Для вычисления среднего арифметического нам нужно знать сумму элементов в списке и их количество. Для этого самостоятельно реализовны два соответствующих предиката.

Длина списка вычисляется рекурсивно. Спускаемся, отсекая голову списку, пока не получим пустой список. А длина пустого списка -- 0. Поднимаемся обратно прибавляя на каждом шагу единицу.
Т.о. знаем длину списка.

Сумма элементов списка вычисляется с той же идеей, только на каждом шаге прибавляется не 1, а головной элемент списка. Т.о. знаем длину сумму списка.

Среднее вычисляется просто как сумма элементов, деленная на их количество.

Пример совместного использования предикатов, разработанных в п. 3, 4.

`swap3_list(L, R)` - предикат для перестановки 3-х последних элементов списка в начало.
Примеры использования:

```prolog
?- swap3_list([1, 2, 3, 4, 5], X).
X = [3, 4, 5, 1, 2].
```

Реализация:

```prolog
swap3_list(List, Res):-
    remove_last3(List, Tmp1),
    append_list(Tmp1, Tmp2, List),
    append_list(Tmp2, Tmp1, Res).
```

Удаляем последние 3 элемента списка, находим элементы, которые удалили и добавляем их в начало полученного в результате удаления списка.

## Задание 2: Реляционное представление данных

Достоинства:

- Эта модель данных отображает информацию в наиболее простой для пользователя форме
- Основана на развитом математи-ческом аппарате, который позволяет достаточно лаконично описать основные операции над данными.
- Позволяет создавать языки манипулирования данными не процедурного типа.
- Манипулирование данными на уровне выходной БД и возможность изменения.

Недостатки:

- Самый медленный доступ к данным.
- Трудоемкость разработки.

Задание (Вариант: задание 3, представление 3):
- Для каждого студента, найти средний балл, и сдал ли он экзамены или нет
- Для каждого предмета, найти количество не сдавших студентов
- Для каждой группы, найти студента (студентов) с максимальным средним баллом

Библиотечный предикат `findall` создает список элементов, для которых истинно условие, передаваемое в предикат. Библиотечный предикат `setof` создает список элементов, для которых истинно условие, передаваемое в предикат, но в таком списке все элементы уникальны.

Для того, чтобы составить списки данных были составлены предикаты:
`bad_studs`, `gr_studs`, `gr_avgs`, `stud_grades`, `grps`. Они создают списки двоечников, студентов в группе, средних баллов по группе, оценок студента и список групп.

Были созданы предикаты `sum_list`, `average_list`, `max_list` для вычисления суммы элементов в списке, получения среднего значения и максимального элемента. Они использованы для подсчета средних баллов и поиска лучших студентов.

Обработав списки формируем и печатаем результаты при помощи предикатов `print_avg_grades`, `print_bad_studs_count`, `print_best_studs`.

## Выводы

Из-за частого программирования на обычных языках программирования было довольно сложно понять как программировать на языке Пролог. Тут не оказалось привычных констрункций, операторов присваивания и прочих вещей, к которым мы привыкли.

Для программирования на прологе списки оказываются незаменимыми во многих задачах.

Для работы со списками часто нужна рекурсия. Большинство операций над списками рекурсивно используют отсечение головы списка пока не сработает условие окончание рекурсии. Те, кототорые не используют ее напрямую, используют другие операции с рекурсией.

Во время работы над этой лабораторной работой были получены знания и навыки в создании операций над списками. Так же были получены умения работы с базой данных языка Пролог.
