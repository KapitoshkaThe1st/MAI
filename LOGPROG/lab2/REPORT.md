# Отчет по лабораторной работе №2
## по курсу "Логическое программирование"

## Решение логических задач

### студент: Куликов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |              |               |
| Левинская М.А.|              |     5         |

## Введение

Существует множество подходов к решению логических задач.
Вот наиболее используюемые из них:

- Метод рассуждений;
- Метод таблиц;
- Метод графов;
- Метод блок-схем;
- Метод бильярда;
- Метод кругов Эйлера.

Пролог оказывается весьма удобным языком для создания решателей логических задач. Все благодаря тому что большинство логических задач могут быть решены методом перебора всех вариантов с наложением на них ограничений, заявленных в условии. А Пролог с его деревом вывода как раз этим и занимается.
Кроме того, многие логические задачи связаны с рассмотрением нескольких конечных множеств с одинаковым количеством элементов, между которыми
устанавливается взаимно-однозначное соответствие. На Прологе эти множества можно описывать как базы данных, а зависимости
между объектами устанавливать с помощью правил.

## Задание

Вариант 9. Один из пяти братьев разбил окно. Андрей сказал: Это или Витя, или Толя. Витя сказал: Это сделал не я и не Юра. Дима сказал: Нет, один из них сказал правду, а другой неправду. Юра сказал: Нет, Дима ты не прав. Их отец, которому, конечно можно доверять, уверен, что не менее трех братьев сказали правду. Кто разбил окно?

## Принцип решения

Утверждения мальчиков очень удобно записываются при помощи стандартных средств логики в Прологе: операторов ".", "," и "not".
Предикат `statement(Speaker, Perp)` будет означать, что Speaker утверждает, что виновник -- Perp.

Утверждения мальчиков могут быть записаны так:

```prolog
statement('Andrey', Perp):-
    Perp = 'Vitya'; Perp = 'Tolya'.

statement('Vitya', Perp):-
    Perp \= 'Vitya', Perp \= 'Yura'.

statement('Dima', Perp):-
    (statement('Andrey', Perp), not(statement('Vitya', Perp)));
    (statement('Vitya', Perp), not(statement('Andrey', Perp))).

statement('Yura', Perp):-
    not(statement('Dima', Perp)).
```

Предикаты `speakers(S)`, `boys(B)` служат просто для получения списка говоривших и списка всех мальчиков соответственно.

```prolog
speakers(S):-
    S = ['Andrey', 'Vitya', 'Dima', 'Yura'].

boys(B):-
    B = ['Andrey', 'Vitya', 'Dima', 'Yura', 'Tolya'].
```

Предикат `truly(L)` проверяет истиность высказываний всех мальчиков в списке L.

```prolog
truly([], _).
truly([H|T], Perp):-
   statement(H, Perp), truly(T, Perp).
```

Предикает `solve(Perp)` выбирает подозреваемого Perp из списка всех мальчиков. Далее из списка говоривших выбирается предполагаемый лжец Liar. После этого при помощи предиката `truly(L)` проверяется выполнимость условия для списка L сказавших правду, и невыполнимость для утверждения лжеца.

Тот подозреваемый, для которого найдутся такие трое правдивых и один лжец и есть виновник.

```prolog
solve(Perp):-
    boys(B), member(Perp, B),
    speakers(S), member(Liar, S),
    delete(S, Liar, List),
    (truly(List, Perp), not(statement(Liar, Perp)));
    speakers(S), truly(S, Perp).
```

По условию задачи отец мальчиков уверен, что правду сказали не меньше трех братьев правдивы. Поэтому в первой части прдиката `solve` проверяются все тройки сказавших правду, а затем, если ни одна тройка не удовлетворила проверке, проверяется вся четверка говоривших.

Говоря об эффективности можно сказать, что вроде бы используется не так много операций перебора. Вместо перебора перестановками в данном случае логично именно выбирать из списка подозреваемых и лжецов, а не обрабатывать их при всех возможных перестановках.

Так же, если я не ошибаюсь, условие `not(statement(Liar, Perp))` является лишним, так как
G & (G -> ~D) = G & ~D, где G - это истиность для какой-то тройки, D - истиность для говорившего мальчика не вошедшего в эту самую тройку.
Условие (G -> ~D) негласно следует из того, что всего три мальчика говорили, и из них сказали правду трое а значит 4-й соврал.

Поэтому явно это условие можно не проверять. При этом результат не должен измениться.

Финальная версия предиката:

```prolog
solve(Perp):-
    boys(B), member(Perp, B),
    speakers(S), member(Liar, S),
    delete(S, Liar, List),
    truly(List, Perp);
    speakers(S), truly(S, Perp).
```

Зацикливаний как-то само по себе не случилось поэтому бороться с ними не пришлось.
Непротиворечивость решений достигнута, по всей видимости, строгими ограничениеми наложенными на всевозможные варианты виновников и лжецов.

Итак, ответ: Толя разбил окно.

## Выводы

Многие задачи (в том числе и данная) на Прологе решаются при помощи генерации всех возможных вариантов, и их последующей фильтрацией предикатами, выражающими условия задачи.
При этом получающаяся программа довольно лаконична и компактна, а ее написание безболезненно. А если представить как выглядел бы ее аналог, написанный на одном традиционных языков программирования, то преимущества Пролога в решении данного класса задач еще более очевидны.

Сложнее всего было подобрать наиболее удачное представление фактов из задачи, чтобы потом их было легче обрабатывать, и при этом не возникало противоречий в решении. Так же заставила задуматься оптимизация. Как сделать меньше переборов? Какие условия избыточны?

В процессе работы над заданием были закреплены знания и умения написания Пролог-программ. В частности, были повторены методы работы со списками.
Как результат создана программа, решающая указанную задачу единственным и, я надеюсь, верным способом.
