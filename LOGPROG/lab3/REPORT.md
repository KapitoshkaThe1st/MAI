# № Отчет по лабораторной работе №3
## по курсу "Логическое программирование"

## Решение задач методом поиска в пространстве состояний

### студент: Куликов А.В.

## Результат проверки

| Преподаватель     | Дата         |  Оценка       |
|-------------------|--------------|---------------|
| Сошников Д.В. |    1.12.18          |    5           |
| Левинская М.А.|              |               |

> Хорошее решение и отчёт!

## Введение

Метод поиска в пространстве состояний применятеся для решения задач искусственного интелекта.

Для того чтобы задача успешно решалась методом поиска в пространстве состояний необходимо, чтобы задача описывалась начальным и конечным состоянием, набором правил перехода между состояними, а так же неким критерием для оценки решения (длина пути, стоимость перехода и т.д.).

Пролог довольно удобен для решения этого класса задач потому что все выше перечисленные требования вполне естественно описываеются на языке Пролог.

Поиск в пространстве состояний по сути своей является поиском в графе, генерируемом "на лету" по правилам перехода между состояниями, алгоритмы обхода котороги либо уже присутствуют в языке Пролог, либо с легкостью на нем реализуются.

Да и в основе самого процесса логического вывода лежит поиск в глубину, что уже говорит о схожести идеи поиска в пространстве состояний и самого языка Пролог. Следовательно Пролог более чем пригоден для решения подобных задач.

## Задание (Вариант 2)

Три миссионера и три каннибала хотят переправиться с левого берега реки на правый. Как это сделать за минимальное число шагов, если в их распоряжении имеется трехместная лодка, и ни при каких обстоятельствах (в лодке или на берегу) миссионеры не должны оставаться в меньшинстве.

## Принцип решения

Данная задача может быть описана заданием начального и конечного состояний и правил перехода между состояниями.

Поэтому для решения задачи применены несколько алгоритмов неинформированного поиска в пространстве состояний.

Состояния описываются структурным термом `state([CLM, CLK],[CRM, CRK], WB)`, где CLM - количество миссионеров на левом берегу, CLK - количество каннибалов на левом берегу, CRM и CRK - количество миссионеров и каннибалов на правом берегу соответственно, WB - позиция лодки (l - левый берег, r - правый).

Начальное состояние задается следующим образом: `state([3, 3], [0, 0], l)`, где `[3, 3]` означает, что на левом берегу изначально 3 миссионера и 3 каннибала, `[0, 0]` - на правом берегу нет никого. При этом лодка у левого берега (`l`). Конечное состояние задается так: `state([0, 0], [3, 3], r)`. Это означает, что все пассажиры переправились и лодка теперь на правом берегу.

Правила перехода между состояниями задаются при помощи предиката `move(S1, S2)`, где S1 - текущее состояние, S2 - состояние после перехода.

К примеру, правило перехода, описывающее переправу с левого берега на правый:

```prolog
move(state([X, Y], [V, W], l), state([XX, YY], [VV, WW], r)):-
    in_pool(CM),    % не больше 3-х миссионеров в лодку
    in_pool(CK),    % не больше 3-х каннибалов в лодку
    (CM >= CK; CM = 0),     % в лодке либо не должно быть миссионеров совсем,
                            % либо должно быть не меньше, чем каннибалов
    S is CM + CK,   % и в сумме
    S =< 3,         % в лодке не больше 3-х пассажиров,
    S > 0,          % но и пустая лодка, не может уплыть
                    % (должен быть минимум один пассажир-гребец)
    XX is X - CM,   % CM миссионеров уплыло
    YY is Y - CK,   % CK каннибалов уплыло
    VV is V + CM,   % CM миссионеров приплыло
    WW is W + CK,   % CK каннибалов приплыло
    possible(state([XX, YY], [VV, WW], r)),     % проверка на возможность состояния
    correct(state([XX, YY], [VV, WW], r)).      % проверка на безопасность состояния
```

Правило для переправы с правого на левый описывается аналогично.

Далее поиск в пространстве состояний происходит при помощи одного из алгоритмов (поиск в глубину, в ширину, с итеративным заглублением).

К примеру, реализация поиска в ширину, на мой взгляд самая интересная из здесь представленных:

```prolog
b_path([[Cur|T]|_], Cur, [Cur|T]).  % если конец текущего пути - целевое состояние, то путь найден
b_path([[Cur|T]|TT], Goal, Result):-    % для первого пути в очереди
    setof(                              % получаем список продолженных  путей
        [Next, Cur|T],
        (move(Cur, Next), not(member(Next, [Cur|T]))),
        New
    ),
    append(TT, New, RR), !,     % добавляем его в конец очереди, удалив уже обработанный путь
    b_path(RR, Goal, Result);   % продолжаем поиск
    b_path(TT, Goal, Result).   % если текущий путь - тупик, и у него нет продолжений,
                                % то ищем продолжения для следующих в очереди

breadth_first_search(Start, Finish, Path, Time):-
    b_path([[Start]], Finish, Reversed_path),   % находим путь (список состояний получается
                                                % инвертированным)
    reverse(Reversed_path, Path),               % переворачиваем чтобы получить в прямом порядке
```

Дабы не нагромождать отчет остальные реализации будут представлены в файле `solution.pl`.

В результате работы любого из алгоритмов поиска получаем цепочку состояний. Чтобы получить последовательность действий для решения задачи "пропускаем" список состояний через предикат `action_sequence(States, Actions)`. Получена последовательность действий.

## Результаты

### Найденные пути решения

#### Поиск в глубину

Поиск в глубину первым решением предлагает переправиться за 11 шагов.

Первый найденный путь:

```prolog
carry([0,2],r)
carry([0,1],l)
carry([0,2],r)
carry([0,1],l)
carry([2,0],r)
carry([1,1],l)
carry([2,0],r)
carry([0,1],l)
carry([0,2],r)
carry([0,1],l)
carry([0,2],r)
```

> *Здесь и далее carry([CM, CK], Dest) означает действие, в результате которого перевезено CM миссионеров и CK каннибалов на берег Dest. Например, carry([2,1],l) - перевезено 2 миссионера и 1 каннибал на левый берег.*

И лишь 23 по счету путем предлагает кратчайший путь к решению задачи в 5 шагов.

Кратчайшее решение:

```prolog
carry([0,2],r)
carry([0,1],l)
carry([3,0],r)
carry([0,1],l)
carry([0,3],r)
```

#### Поиск в ширину

После запуска поиска в ширину сразу был найден кратчайший путь (как и ожидалось) длины 5 для решения задачи.

Кратчайший путь:

```prolog
carry([1,1],r)
carry([1,0],l)
carry([3,0],r)
carry([0,1],l)
carry([0,3],r)
```

#### Поиск с итеративным заглублением

Поиск с итеративным заглублением так же оправдал ожидания и сразу нашел кратчайший путь длины 5 для решения задачи.

Кратчайший путь:

```prolog
carry([0,2],r)
carry([0,1],l)
carry([3,0],r)
carry([0,1],l)
carry([0,3],r)
```

### Сравнительный анализ

После проведения испытаний всех трех алгоритмов для решения данной задачи были получены следующие результаты:

| Алгоритм поиска | Длина найденного первым пути | Время работы |
|-----------------|------------------------------|--------------|
| В глубину       | 12                           | 0.00062      |
| В ширину        | 6                            | 0.00445      |
| ID              | 6                            | 0.00582      |

Поиск в глубину оказался самым быстрым. За ним идет алгоритм поиска в ширину. Последним "пришел"
поиск с итеративным заглублением.

Такая расстановка позиций объяснеятся тем, что поиск в глубину уже заложен в системе логического вывода языка Пролог. Мы лишь записываем его шаги. Именно поэтому поиск в глубину расположился на первом месте.

Далее все немного интереснее. Поиск в ширину оказался быстрее для решения данной конкретной задачи, хотя во многих источниках поиск с итерационным заглублением указывается как предпочтительный.

Это объясняется (в моем представлении) тем, что поиск с итеративным заглублением после каждого заглубления "забывает" уже полученные пути меньшей длины, и вынужден вычислять их каждый раз с нуля. Тогда как поиск в ширину хранит все пути-кандидаты и на каждом шагу лишь продляет их, если это возможно.

К тому же, несомненно, свою лепту внес тот факт, данные реализации алгоритмов поиска не являются оптимальными. С уверенностью можно сказать, что сущетсвуют лучшие реализации.

Однако быстро не значит хорошо. Поиск в глубину находит оптимальное решение не с первого раза, а лишь с 23.
Остальные же два алгоритма с первой попытки приходят пускай к разным, но оптимальным решениям.

Если же оценивать пространственную сложность алгоритмов, то тут вполне естественно проигрывает поиск в ширину т.к. он хранит очередь всех путей-кандидатов. Другие же два алгоритма работают с одним путем в один момент времени.

### Ответ

Итак, ответом к данной задачи является следующая последовательность действий:

```prolog
carry([1,1],r)
carry([1,0],l)
carry([3,0],r)
carry([0,1],l)
carry([0,3],r)
```

Так же существуют другие пути такой же длинны. Ответ на задачу не является однозначным.

## Выводы

Алгоритм поиска в глубину имеет смысл использовать, если не принципиально какой путь будет найден, а важно лишь его наличие или отсутсвие. Но данный алгоритм может и, весьма вероятно,
пропустит решения, уйдя по бесконечному пути, если пространство состояний, соответственно, бесконечно.

Алгоритм поиска в ширину целесообразно использовать, когда необходимо найти (довольно быстро) именно оптимальное решение, и при этом не критичен объем используемой памяти. К тому же ему не страшны бесконечно длинные пути, но страшны состояния с большим количеством разветвлений. Они могут привести к чрезмерному расходу памяти.

Алгоритм поиска с итерационным заглублением используется, когда необходимо найти оптимальное решение, при этом важно количество занимаемой памяти. Данный алгоритм так же чувствителен к указанным выше состояниям.

Во всей видимости, для данной задачи наилучшим алгоритмом поиска является алгоритм поиска в ширину. Это обусловлено тем, что кратчайшее решение лежит на относительно малой глубине (на глубине 6), что не позволяет случиться комбинаторному взрыву и использовать сколь угодно значимые объемы памяти. Также, по указанным выше причинам, поиск в ширину оказался несколько быстрее для решения задачи (в 1.3 раза). Поиск в глубину же "отпал" т.к. он предлагает неоптимальное решение. Поэтому предпочтение было отдано именно поиску в ширину.

В прикладных задачах почти всегда стоит отдавать предпочтение эвристическому поиску, такому как A*, лучевой и т.п. Но для данной задачи это было бы "как из пушки по воробьям" и, к тому же, их немного сложновато реализовать.

Итак, процессе работы над данной задачей были изучены основные методы неинфоримрованного поиска в пространстве состояний, релизованы и применены к одной из конкретных задач. Указанные алгоритмы были проанализированы и оценены с практической точки зрения. Были найдены их достоинства и недостатки. Таким образом произошло поверхностное знакомство с искуственным интелектом.
